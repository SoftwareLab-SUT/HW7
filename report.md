# آزمایش هفتم
مهرانه نجفی (۹۷۱۰۴۷۰۷)، رستا روغنی(۹۷۱۰۵۹۶۳) 

**نکات انجام آزمایش**

**شرح تغییرات روی کد**

-*اضافه کردن Control Statement Braces*

در هر پروژه برای اینکه وضوح و نظم پروژه بیشتر باشد نیاز است که ساختارها رعایت شوند به همین دلیل مثلا در ساختار یک if statement نیاز است که شکل آن رعایت شود تا بی‌نظمی و آشفتگی ایجاد نشود. در این پروژه هرجا if statement یا for وجود داشت که brace های آن گذاشته نشده، آن را اضافه کردیم.

-*برقراری Loose Coupling*

برای برقرای loose coupling از List بجای ArrayList استفاده می‌کنیم در این صورت متد یا کلاس مدنظر واقعا در جریان اینکه از کدام زیرمجموعه‌ی List استفاده می‌کنیم اطلاعی نخواهد داشت. در این صورت می‌توان به یک پیاده‌سازی دیگر تغییر کاربری داد بدون اینکه تغییر زیادی از سمت API نیاز باشد.

-*رعایت Self Encapsulate Field*

در کلاس‌های مختلف فیلد‌های خصوصی متعددی وجود دارند. بجای اینکه در متد‌های این کلاس مستقیما به فیلد خصوصی دسترسی پیدا کنیم که خطرات خود را دارد، از getter برای گرفتن آن فیلد استفاده می‌کنیم که نظم و ساختار صحیح کد حفظ شود.

-*پیاده‌سازی State/Strategy Pattern*

در کلاس Action بجای اینکه در سوییچ به کارهای مختلف بپردازیم یک State Pattern را پیاده‌سازی کردیم که در آن ۳ کلاس برای انواع اکشن‌ها تعریف می‌کنیم که همگی از یک ابسترکت ارث‌بری می‌کنند. در سوییچ مشخص می‌کنیم که فیلد درون کلاس با نام action که عضوی از کلاس ابسترکت است، واقعا یک شی از کدام‌یک از کلاس‌های تازه تاسیس‌شده خواهد بود.

این کار را مشابها در کلاس Address هم پیاده کردیم و انواع آدرس را به کلاس‌هایی مجزا که از یک ابسترکت ارث‌بری می‌کنند تبدیل کردیم.

-*رعایت Separate Query from Modifier*

در یک کلاس یک تابع بهتر است یا تنها اطلاعاتی را جمع‌آوری کند یا تغییراتی روی فیلد‌ها بدهد و بهتر است این دو از هم جدا باشند. برای اینکار در فایل Memory.java توابع getTemp، getDateAddress و saveMemory را به نوعی تغییر دادیم تا بخشی که تغییراتی روی فیلد‌های کلاس می‌دهد در یک تابع جدا انجام شود و بخشی که اطلاعاتی را کسب می‌کند در یک قسمت باشد.

-*رفع Code Duplication*

در فایل CodeGenerator.java دو تابع برای جمع و تفریق وجود دارند که بسیار مشابه یکدیگر هستنند. در چنین شرایطی بهتر است به جای اینکه خط‌های تکراری زیادی بنویسم این دو تابع را با هم ترکیب کرده و به تناسب نیاز در قسمت‌هایی که توابع گذشته‌ی add و sub هستند استفاده کنیم.

-*ایجاد Facade*

در فایل Parser.java یکی از قسمت‌های مهم یک سوییچ است که به تناسب می‌تواند ما را به حالت پذیرش یا غیره ببرد. در اینجا برای اینکه این کار مشخصا دست یک کامپوننت باشد یک facade تعریف کردیم که این کار سوییچ را برای ما انجام و نتیجه را خروجی می‌دهد. در این صورت مشخص خواهد بود که این کار را چه کلاسی انجام داده، چه اتفاقی افتاده و با اینکه حجم کد بیشتر می‌شود اما نظم و ساختار را بهتر می‌کند.


**پرسش‌ها**

۱- هریک از مفاهیم زیر را در حد یک خط توضیح دهید.

الف) کد تمیز: به کدی گفته می‌شود که خوانایی بالا داشته‌باشد (ساده باشد) و درک، نگهداری و تست کردن آن آسان باشد. کد تمیز، فرایند توسعه نرم‌افزار را قابل پیش‌بینی می‌کند و کیفیت محصول نهایی را بالا می‌برد. 

ب) بدهی فنی: زمانی پیش می‌آید که تیم‌ها برای پیاده‌سازی پروژه راه‌‌حل ساده‌تر و سریعتر را به‌جای راه‌حل بهتر و طولانی‌تر انتخاب می‌کنند و در انتها مشکلاتی ایجاد می‌شوند که باید هزینه‌ی مضافی برای refactoring شان پرداخت. 

ج) بوی بد: ویژگی‌هایی از کد اصلی هستند که ممکن است نشانه‌ی مشکلات عمیق‌تری باشند و کیفیت برنامه را پایین می‌آورند. تشخیص بوهای بد ساده است و در فرایند refactoring می‌توان آن‌ها را درست کرد.  

۲- طبق دسته‌بندی وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته تقسیم می‌شوند. درمورد هرکدام از این پنج دسته توضیح مختصری بدهید.

دسته‌ی Bloaters: کدها، متدها و کلاس‌هایی هستند که بسیار حجیم شده‌اند و کار کردن با آن‌ها سخت است. این دسته‌ از بوها به مرور زمان و با اضافه کردن قابلیت‌های جدید به وجود می‌آیند. از نمونه‌های آن می‌توان به Long Method (متدهای معمولا طولانی‌تر از ده خط) و Primitive Obsession (استفاده از primitive به جای اشیای کوچک و یا استفاده از constantها برای ذخیره اطلاعات) اشاره کرد.

دسته‌ی Object-Orientation Abusers: نتیجه‌ی استفاده‌ی ناقص و یا اشتباه از اصول برنامه‌نویسی شی‌گرا هستند. Temporary Field (استفاده از فیلدهایی که کلاس‌های دیگر از آن‌ها استفاده می‌کنند اما تنها در شرایطی خاص مقداردهی می‌شوند و باقی زمان‌ها خالی هستند)  و Switch Statements (داشتن switch پیچیده یا دنباله‌ای طولانی از ifها) از نمونه‌های این دسته بو هستند. 

دسته‌ی Change Preventers: به این معنی‌اند که اگر تغییر در یک بخش از کد، ما را مجبور می‌کند که تغییرات زیادی در بخش‌های دیگر نیز بدهیم. بنابراین اضافه کردن فیچرهای جدید به برنامه بسیار زمان‌بر می‌شود. از نمونه‌های آن می‌توان به Shotgun Surgery (زمانی که یک تغییر کوچک باید در هم‌زمان در چندین کلاس پیاده‌سازی شود) و Divergent Change (زمانی که تعداد زیادی تغییر روی یک کلاس اعمال بشوند و مجبور باشیم متدهای غیرمرتیط را تغییر بدهیم) اشاره کرد.

دسته‌ی Dispensables: بخش‌هایی از برنامه هستند که کاربرد و هدفی ندارند و حذف کردن‌شان کد را تمیزتر، خواناتر و کارآمدتر می‌کند. Comments (برنامه پر از کامنت‌های طولانی باشد که خودش به نحوی نشانه‌ی این است که کدی که نوشتیم خوانایی ندارد) ، Duplicate Code (کدهایی که دقیقا مشابه هم باشند) و Dead Code (فیلد یا متغیر یا کلاسی که دیگر نیازی به آن نیست) از نمونه‌‌های این بو هستند. 

دسته‌ی Couplers: منجر به coupling بیش از حد بین کلاس‌ها و یا کل ماژول‌ها می‌شوند. از نمونه‌های آن Feature Envy (زمانی که یک کلاس از فیچرهای کلاسی دیگر خیلی زیاد و حتی بیشتر از داده‌های خودش استفاده کند) ، Middle Man (استفاده از کلاسی که مانند یک مجرا عمل می‌کند و کارها را به کلاس دیگری می‌فرستد) و Message Chains (وجود کدهایی در برنامه که به‌صورت زنجیروار فیلدها و کلاس‌های دیگر را صدا می‌کنند) هستند.  


۳- یکی از انواع بوهای بد Lazy Class است. 

الف) این بوی بد در کدام یک از دسته‌بندی‌های پنجگانه قرار می‌گیرد؟ در دسته‌ی Dispensables قرار دارد. 

ب) برای برطرف کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟

برای اجزایی که تقریبا بی‌استفاده هستند، از بازآرایی inline class استفاده می‌شود. در این روش اجزا‌ی مدنظر را کلا به کلاس دیگری منتقل می‌کنیم (ابتدا فیلدها و متدهای public را منتقل می‌کنیم و پس از اطمینان از کارکرد درست آن‌ها باقی متدها و فیلدها را جابجا می‌کنیم). همچنین اگر در جایی رفرنس به Lazy Class داده شده‌بود، آن را به این کلاس جدید تغییر می‌دهیم.

برای کلاس‌هایی که از Lazy Class ارث‌بری کرده‌اند و کاربردهای کمی دارند، از بازآرایی Collapse Hierarchy استفاده می‌شود. در این روش آن دسته از فیلدها و متدهایی که کلاس‌‌های بچه ارث‌بری کرده‌اند را مستقیما در خودشان تعریف می‌کنیم و از کلاس پدر حذف‌شان می‌کنیم. همچنین رفرنس‌های کلاس پدر را در کد به رفرنس‌های خود بچه‌ها تغییر می‌دهیم. درانتها هم کلاس پدر را حذف می‌کنیم.

ج) در چه مواقعی باید این بو را نادیده گرفت؟ گاهی یک کلاس ساخته می‌شود تا چهارچوب اهدافی که برای توسعه داریم را مشخص کند. در این صورت می‌توان این بو را نادیده گرفت اما باید تلاش کرد که یک تعادل بین سادگی و شفافیت کد برقرار کرد.
